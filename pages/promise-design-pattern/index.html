<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>promise-design-pattern</title>
    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/skeleton/2.0.4/skeleton.min.css" integrity="sha512-EZLkOqwILORob+p0BXZc+Vm3RgJBOe1Iq/0fiI7r/wJgzOFZMlsqTa29UEl6v6U6gsV4uIpsNZoV32YZqrCRCQ==" crossorigin="anonymous"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha512-NhSC1YmyruXifcj/KFRWoC561YpHpc5Jtzgvbuzx5VozKpWvQ+4nXhPdFgmx8xqexRcpAglTj9sIBWINXa8x5w==" crossorigin="anonymous"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.6.0/styles/stackoverflow-light.min.css" integrity="sha512-cG1IdFxqipi3gqLmksLtuk13C+hBa57a6zpWxMeoY3Q9O6ooFxq50DayCdm0QrDgZjMUn23z/0PMZlgft7Yp5Q==" crossorigin="anonymous"/>
    <link rel="stylesheet" href="../../preview.css">
    <link rel="stylesheet" href="style.css">
     
     
      </head>
  <body>
    <div class="main-content">

      <div>
        <ul>
          <li><a href="../../">Back to HOME</a></li>
        </ul>
      </div>

      <div id="app"></div>

      <div class="injected-readme">
      <!-- inject:readme:md -->
      <h1 id="promise-design-pattern">Promise Design Pattern</h1>
<p>Promises provides a powerful async pattern in Javascript. Lots and losts of API&#39;s use promises. </p>
<ul>
<li>A promise is simply a Javascript Object with properties &amp; methods. </li>
<li>This Object (Promise) represents the eventual completing (or failure) of an Async Operation.</li>
<li>When the opration completes, the Promise provides a resulting value.</li>
</ul>
<p>This is how we construct a promise (Promise <em>producing</em> code):</p>
<pre><code class="language-js"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>{
  <span class="hljs-comment">// executor : do something here...</span>
})
</code></pre>
<p>The function passed to a new Promise is called the <em>executor</em>. The executor is called automatically and immediately by <code>new Promise</code>. When the executor obtains the result, it should call one of these callbacks:</p>
<ul>
<li><code>resolve(value)</code></li>
<li><code>reject(value)</code></li>
</ul>
<p>The <code>promise</code> object returned by the <code>new Promise</code> constructor has these internal propterties:</p>
<ul>
<li><code>state</code> initially set to <code>pending</code>, then changes to either <code>fulfilled</code> or <code>rejected</code>. The <code>state</code> changes to <code>fulfilled</code> when <code>resolved</code> is called or it changes to <code>rejected</code> when <code>reject</code> is called.</li>
<li><code>result</code> is initially <code>undefined</code>, then it changes to <code>value</code> when <code>resolve(value)</code> is called or it changes to <code>error</code> when <code>reject(error)</code> is called.</li>
</ul>
<p>The properties <code>state</code> and <code>result</code> of the Promise object are internal. We can&#39;t directly access them, we can use the methods <code>.then()</code> / <code>.catch()</code> / <code>.finally()</code> for that. These are called <em>consumer functions</em> in the world of Promise.</p>
<h3 id="then">then</h3>
<p>The most important, fundamental one is <code>.then</code>.</p>
<p>The syntax is:</p>
<pre><code class="language-javascript">  promise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>)</span>{}, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>{});
</code></pre>
<h3 id="catch">catch</h3>
<p><code>.catch(function(error){})</code> takes just one callback to handle errors.</p>
<p>The syntax is:</p>
<pre><code class="language-js">  promise.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>{});
</code></pre>
<h3 id="finally">finally</h3>
<p><code>.finally()</code> runs when a promise is settles, it doesn&#39;t matter wether the promise was resolved or rejected.</p>
<ul>
<li>A <code>finally</code> handler has no arguments. </li>
<li>A <code>finally</code> handler passes through the results and errors to the next handler. So, technically we can chain a <code>.then</code> to a <code>.finally</code>. Remember, <code>finally</code> is not meant to process a promise result, so, it passes through.</li>
</ul>

      <!-- endinject -->
      </div>

    </div>
    <script type="module" defer src="script.js"></script>
  </body>
</html>
